"""
Spec Processor - Generate and validate specifications
"""

from pathlib import Path
from typing import Dict, Any, Optional
import json


class SpecProcessor:
    """Process and generate feature specifications"""

    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)

    def generate_spec(self, feature_name: str, requirements: Dict[str, Any]) -> str:
        """
        Generate a specification document for a feature

        Args:
            feature_name: Name of the feature
            requirements: Dictionary containing requirement details

        Returns:
            Generated spec content as markdown string
        """
        spec_template = f"""# Feature Specification: {feature_name}

## Overview
{requirements.get('overview', 'Brief description of the feature to be implemented.')}

## Requirements

### Functional Requirements
{self._format_requirements(requirements.get('functional_requirements', []))}

### Non-Functional Requirements
{self._format_requirements(requirements.get('non_functional_requirements', []))}

## Success Criteria
{self._format_criteria(requirements.get('success_criteria', []))}

## Acceptance Criteria
{self._format_criteria(requirements.get('acceptance_criteria', []))}

## Scope
{requirements.get('scope', 'Define what is in scope and out of scope for this feature.')}

## Assumptions
{self._format_list(requirements.get('assumptions', []))}

## Dependencies
{self._format_list(requirements.get('dependencies', []))}

## Business Value
{requirements.get('business_value', 'Describe the business value this feature provides.')}

## Risk Assessment
{self._format_risks(requirements.get('risks', []))}

## Timeline
{requirements.get('timeline', 'Estimated timeline for implementation.')}

---
*Generated by Super Prompt SDD System*
"""

        return spec_template

    def validate_spec(self, spec_path: Path) -> Dict[str, Any]:
        """Validate a specification file"""
        if not spec_path.exists():
            return {"valid": False, "errors": ["Spec file does not exist"]}

        try:
            content = spec_path.read_text()

            validation_results = {
                "valid": True,
                "errors": [],
                "warnings": [],
                "score": 100
            }

            # Check required sections
            required_sections = [
                "## Overview",
                "## Requirements",
                "## Success Criteria",
                "## Acceptance Criteria"
            ]

            for section in required_sections:
                if section not in content:
                    validation_results["errors"].append(f"Missing required section: {section}")
                    validation_results["score"] -= 25

            # Check for REQ-ID format
            if "REQ-" not in content:
                validation_results["warnings"].append("Consider adding REQ-ID references for traceability")

            # Check content completeness
            if len(content.split()) < 100:
                validation_results["warnings"].append("Specification appears to be too brief")
                validation_results["score"] -= 10

            if validation_results["errors"]:
                validation_results["valid"] = False

            return validation_results

        except Exception as e:
            return {"valid": False, "errors": [f"Error reading spec file: {e}"]}

    def _format_requirements(self, requirements: list) -> str:
        """Format requirements list"""
        if not requirements:
            return "- Requirement 1\n- Requirement 2\n- Requirement 3"

        return "\n".join(f"- {req}" for req in requirements)

    def _format_criteria(self, criteria: list) -> str:
        """Format criteria list"""
        if not criteria:
            return "- [ ] Criterion 1\n- [ ] Criterion 2\n- [ ] Criterion 3"

        return "\n".join(f"- [ ] {crit}" for crit in criteria)

    def _format_list(self, items: list) -> str:
        """Format generic list"""
        if not items:
            return "- Item 1\n- Item 2\n- Item 3"

        return "\n".join(f"- {item}" for item in items)

    def _format_risks(self, risks: list) -> str:
        """Format risks list"""
        if not risks:
            return "- **High Risk**: Description of high impact risk\n- **Medium Risk**: Description of medium impact risk"

        return "\n".join(f"- **{risk.get('level', 'Unknown')}**: {risk.get('description', 'No description')}" for risk in risks)
