"""
Cursor IDE Adapter - Generate Cursor-specific integrations
"""

from pathlib import Path
from typing import Dict, Any, List
import json
import yaml


class CursorAdapter:
    """Adapter for Cursor IDE integration"""

    def __init__(self):
        self.project_root = Path(__file__).parent.parent.parent.parent
        self.assets_root = self.project_root / "packages" / "cursor-assets"

    def load_personas_manifest(self) -> Dict[str, Any]:
        """Load personas from data-driven manifest"""
        manifest_path = self.assets_root / "manifests" / "personas.yaml"
        if manifest_path.exists():
            with open(manifest_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        return {"personas": {}}

    def generate_commands(self, project_root: Path) -> None:
        """Generate Cursor slash commands from manifests"""
        commands_dir = project_root / ".cursor" / "commands" / "super-prompt"
        commands_dir.mkdir(parents=True, exist_ok=True)

        # Load personas from manifest
        manifest = self.load_personas_manifest()
        personas = manifest.get("personas", {})

        # Generate command files for each persona in manifest
        for persona_key, persona_config in personas.items():
            self._generate_persona_command(commands_dir, persona_key, persona_config)

        # Generate SDD commands
        self._generate_sdd_commands(commands_dir)

    def _generate_persona_command(self, commands_dir: Path, persona: str, persona_config: Dict[str, Any]) -> None:
        """Generate a persona command file from manifest data"""
        command_file = commands_dir / f"{persona}.py"
        name = persona_config.get("name", persona.title())
        icon = persona_config.get("icon", "🤖")
        description = persona_config.get("description", f"{name} persona")

        content = f'''#!/usr/bin/env python3
"""
{name} Persona Command - Cursor Wrapper
{description}
"""

import subprocess
import sys
import os

def main():
    # Use enhanced persona processor for all personas
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.join(script_dir, '..', '..', '..')
    processor_path = os.path.join(project_root, '.super-prompt', 'utils', 'cursor-processors', 'enhanced_persona_processor.py')

    # Execute the enhanced persona processor
    subprocess.run([
        'python3', processor_path,
        '--persona', '{persona}',
        '--user-input', ' '.join(sys.argv[1:]) if sys.argv[1:] else 'Hello! How can I help you today?'
    ], check=False)

if __name__ == "__main__":
    main()
'''

        command_file.write_text(content)

    def _generate_sdd_commands(self, commands_dir: Path) -> None:
        """Generate SDD workflow commands"""
        sdd_commands = {
            "specify": "Create Feature Specification",
            "plan": "Create Implementation Plan",
            "tasks": "Create Task Breakdown",
            "implement": "Execute Implementation"
        }

        for cmd_name, description in sdd_commands.items():
            command_file = commands_dir / f"{cmd_name}.py"

            content = f'''#!/usr/bin/env python3
"""
{cmd_name.title()} Command - {description}
SDD workflow integration
"""

import subprocess
import sys
import os

def main():
    # Path to the SDD processor
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.join(script_dir, '..', '..', '..')
    processor_path = os.path.join(project_root, '.super-prompt', 'utils', 'sdd', '{cmd_name}_processor.py')

    # Execute the SDD processor
    subprocess.run([
        'python3', processor_path
    ] + sys.argv[1:], check=False)

if __name__ == "__main__":
    main()
'''

            command_file.write_text(content)

    def generate_rules(self, project_root: Path) -> None:
        """Generate Cursor rules files"""
        rules_dir = project_root / ".cursor" / "rules"
        rules_dir.mkdir(parents=True, exist_ok=True)

        # Generate SDD rules
        self._generate_sdd_rules(rules_dir)

        # Generate persona rules
        self._generate_persona_rules(rules_dir)

    def _generate_sdd_rules(self, rules_dir: Path) -> None:
        """Generate SDD-related rules"""
        sdd_rule = rules_dir / "10-sdd-core.mdc"

        content = '''---
description: "SDD core & self-check — generated by Super Prompt v3"
globs: ["**/*"]
alwaysApply: true
---
# Spec-Driven Development (SDD)
1) No implementation before SPEC and PLAN are approved.
2) SPEC: goals/user value/success criteria/scope boundaries — avoid premature stack choices.
3) PLAN: architecture/constraints/NFR/risks/security/data design.
4) TASKS: small, testable units with tracking IDs.
5) Implementation must pass the Acceptance Self-Check before PR.

## Current SDD Status
- **SPEC Files Found**: 0 files
- **PLAN Files Found**: 0 files
- **SDD Compliance**: ❌ Missing SPEC/PLAN files

## Acceptance Self-Check (auto-draft)
- ✅ Validate success criteria from SPEC
- ✅ Verify agreed non-functional constraints (performance/security as applicable)
- ✅ Ensure safe logging (no secrets/PII) and consistent output
- ✅ Add regression tests for new functionality
- ✅ Update documentation

## Framework Context
- **Detected Frameworks**: python, javascript
- **Project Structure**: SDD-compliant organization required
'''

        sdd_rule.write_text(content)

    def _generate_persona_rules(self, rules_dir: Path) -> None:
        """Generate persona-related rules"""
        persona_rule = rules_dir / "15-personas.mdc"

        content = '''---
description: "Persona behaviors and interaction patterns"
globs: ["**/*"]
alwaysApply: false
---
# Persona System
- **Architect**: System design, scalability, architecture decisions
- **Frontend**: UI/UX, accessibility, modern web development
- **Backend**: APIs, databases, server-side reliability
- **Security**: Threat modeling, security hardening, compliance
- **Performance**: Optimization, bottleneck analysis, monitoring
- **Analyzer**: Root cause analysis, systematic debugging

## Interaction Guidelines
- Each persona has specialized expertise and communication style
- Auto-activation based on query patterns and context
- Quality gates ensure appropriate persona selection
- Cross-persona collaboration for complex problems
'''

        persona_rule.write_text(content)
