# Super Prompt v3 Architecture

**Production-ready prompt engineering toolkit** with modular architecture, dual IDE support, and intelligent reasoning optimization.

## üèóÔ∏è System Overview

Super Prompt v3 is built on a **modular architecture** that separates concerns into distinct layers:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     User Interface Layer                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Cursor IDE        ‚îÇ         Codex CLI                     ‚îÇ
‚îÇ   Slash Commands    ‚îÇ         Flag-based Commands           ‚îÇ
‚îÇ   /architect        ‚îÇ         --sp-architect                ‚îÇ
‚îÇ   /frontend         ‚îÇ         --sp-frontend                 ‚îÇ
‚îÇ   /init-sp          ‚îÇ         super-prompt init             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Command Router                           ‚îÇ
‚îÇ   ‚Ä¢ CLI Wrapper (bin/super-prompt)                         ‚îÇ
‚îÇ   ‚Ä¢ Command Detection & Mapping                            ‚îÇ
‚îÇ   ‚Ä¢ Legacy Compatibility (super:init ‚Üí init)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  Core Engine Layer                         ‚îÇ
‚îÇ   ‚Ä¢ Python Core (packages/core-py/)                        ‚îÇ
‚îÇ   ‚Ä¢ Execution Pipeline                                     ‚îÇ
‚îÇ   ‚Ä¢ AMR (Auto Model Router)                                ‚îÇ
‚îÇ   ‚Ä¢ State Machine                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Service Layer                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Personas    ‚îÇ    Context      ‚îÇ         SDD               ‚îÇ
‚îÇ   ‚Ä¢ Architect ‚îÇ    ‚Ä¢ Collector  ‚îÇ    ‚Ä¢ Spec-Driven Dev     ‚îÇ
‚îÇ   ‚Ä¢ Frontend  ‚îÇ    ‚Ä¢ Cache      ‚îÇ    ‚Ä¢ Quality Gates       ‚îÇ
‚îÇ   ‚Ä¢ Security  ‚îÇ    ‚Ä¢ Tokenizer  ‚îÇ    ‚Ä¢ Pipeline             ‚îÇ
‚îÇ   ‚Ä¢ Backend   ‚îÇ                 ‚îÇ                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Adapter Layer                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Cursor Adapter    ‚îÇ         Codex Adapter                ‚îÇ
‚îÇ   ‚Ä¢ Command Gen     ‚îÇ         ‚Ä¢ Asset Generation           ‚îÇ
‚îÇ   ‚Ä¢ Rules Gen       ‚îÇ         ‚Ä¢ Bootstrap Scripts          ‚îÇ
‚îÇ   ‚Ä¢ Integration     ‚îÇ         ‚Ä¢ AMR Configuration          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üß† Core Components

### 1. Command Router (`bin/super-prompt`)

**Intelligent routing system** that handles command detection and mapping:

```bash
# Legacy compatibility mapping
super:init ‚Üí init

# Persona detection
--sp-architect ‚Üí Enhanced Persona Processor

# Direct CLI delegation
super-prompt init ‚Üí Python Core CLI
```

**Key Features:**
- **Legacy Support**: Maps `super:init` to modern `init` command
- **Persona Routing**: Direct routing for `--sp-*` flags
- **CLI Resolution**: Project-local vs. packaged CLI selection
- **Error Handling**: Graceful fallbacks and clear error messages

### 2. Python Core Engine (`packages/core-py/`)

**Modular Python architecture** with clean separation of concerns:

```
packages/core-py/super_prompt/
‚îú‚îÄ‚îÄ cli.py                 # Main CLI interface
‚îú‚îÄ‚îÄ engine/
‚îÇ   ‚îú‚îÄ‚îÄ execution_pipeline.py  # Task execution
‚îÇ   ‚îú‚îÄ‚îÄ amr_router.py          # Auto Model Router
‚îÇ   ‚îî‚îÄ‚îÄ state_machine.py       # Workflow state
‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îú‚îÄ‚îÄ collector.py           # Context gathering
‚îÇ   ‚îú‚îÄ‚îÄ cache.py               # Caching system
‚îÇ   ‚îî‚îÄ‚îÄ tokenizer.py           # Token management
‚îú‚îÄ‚îÄ personas/
‚îÇ   ‚îú‚îÄ‚îÄ loader.py              # Persona loading
‚îÇ   ‚îî‚îÄ‚îÄ config.py              # Configuration
‚îú‚îÄ‚îÄ sdd/
‚îÇ   ‚îú‚îÄ‚îÄ gates.py               # Quality gates
‚îÇ   ‚îú‚îÄ‚îÄ spec_processor.py      # Spec handling
‚îÇ   ‚îî‚îÄ‚îÄ tasks_processor.py     # Task management
‚îú‚îÄ‚îÄ adapters/
‚îÇ   ‚îú‚îÄ‚îÄ cursor_adapter.py      # Cursor integration
‚îÇ   ‚îî‚îÄ‚îÄ codex_adapter.py       # Codex integration
‚îî‚îÄ‚îÄ validation/
    ‚îú‚îÄ‚îÄ quality_checker.py     # Quality assurance
    ‚îî‚îÄ‚îÄ todo_validator.py      # Task validation
```

### 3. AMR (Auto Model Router)

**Intelligent reasoning optimization** with automatic model switching:

```python
# State Machine: INTENT ‚Üí CLASSIFY ‚Üí PLAN ‚Üí EXECUTE ‚Üí VERIFY ‚Üí REPORT
class AMRRouter:
    def route_request(self, complexity: float, context: dict):
        if complexity > 0.7:
            return "gpt-5-high"  # Deep reasoning
        else:
            return "gpt-5-medium"  # Standard execution
```

**Features:**
- **Automatic Switching**: Based on task complexity analysis
- **Context Awareness**: Considers current project state
- **Performance Optimization**: 30-50% token reduction
- **Quality Gates**: Validation at each stage

### 4. Persona System

**29 Specialized AI personalities** for domain-specific tasks:

#### Technical Specialists
- **`architect`**: Systems design, long-term architecture
- **`frontend`**: UI/UX, accessibility, performance
- **`backend`**: Server-side, APIs, reliability
- **`security`**: Threat modeling, vulnerability assessment
- **`performance`**: Optimization, bottleneck elimination

#### Process Experts
- **`analyzer`**: Root cause analysis, investigation
- **`qa`**: Quality assurance, testing strategies
- **`refactorer`**: Code quality, technical debt
- **`devops`**: Infrastructure, deployment automation

#### Communication Specialists
- **`mentor`**: Educational guidance, knowledge transfer
- **`scribe`**: Documentation, professional writing

**Persona Configuration:**
```yaml
personas:
  architect:
    name: "Systems Architect"
    role_type: "Technical Leadership"
    expertise_level: "Senior"
    specializations: ["system-design", "scalability", "architecture"]
    interaction_style: "Strategic and long-term focused"
```

### 5. SDD (Spec-Driven Development)

**Complete development workflow** with quality gates:

```
SPEC ‚Üí PLAN ‚Üí TASKS ‚Üí IMPLEMENT
  ‚Üì      ‚Üì       ‚Üì        ‚Üì
Gate1  Gate2   Gate3   Gate4
```

**Quality Gates:**
1. **Specification Gate**: Requirements clarity, completeness
2. **Planning Gate**: Technical feasibility, resource estimation
3. **Task Gate**: Implementation readiness, dependency resolution
4. **Implementation Gate**: Code quality, testing, documentation

## üîÑ Execution Flow

### 1. Command Processing
```bash
user: /super-prompt/analyzer super-prompt super:init
  ‚Üì
bin/super-prompt detects super:init ‚Üí maps to init
  ‚Üì
Enhanced Persona Processor (analyzer persona)
  ‚Üì
Python Core CLI (init command)
  ‚Üì
Execution Pipeline + Quality Gates
  ‚Üì
Result with validation and documentation
```

### 2. Persona Activation
```bash
user: --sp-architect "design authentication system"
  ‚Üì
Persona detection (--sp-architect)
  ‚Üì
Enhanced Persona Processor loads architect config
  ‚Üì
System prompt + persona context + user input
  ‚Üì
AI execution with architect specializations
  ‚Üì
Structured output with architectural recommendations
```

### 3. SDD Workflow
```bash
user: super-prompt --sp-sdd-spec "user authentication"
  ‚Üì
SDD Spec Processor
  ‚Üì
Quality Gate 1 (Specification validation)
  ‚Üì
Spec generation with requirements analysis
  ‚Üì
Context preservation for next stage (PLAN)
```

## üõ°Ô∏è Security & Quality

### Security Features
- **Path Validation**: Prevents access to sensitive directories (`.git`, `.cursor`, `.npm`)
- **Input Sanitization**: Comprehensive validation of user inputs
- **Context Isolation**: Secure JSON-based context passing
- **Permission Control**: Controlled file system access

### Quality Assurance
- **8-Step Validation Cycle**: Comprehensive quality gates
- **Automated Testing**: Unit, integration, and E2E tests
- **TODO Validation**: Automatic task completion verification
- **Performance Monitoring**: Token usage and execution time tracking

### Global Write Protection
```python
# Only safe outputs allowed
SAFE_WRITE_PATTERNS = [
    ".codex/reports/",
    "specs/",
    "memory/constitution/",
    "memory/rules/"
]
```

## üìä Performance Optimization

### Token Management
- **Context Engineering**: 30-50% token reduction
- **Intelligent Caching**: Context reuse across sessions
- **Selective Injection**: Only relevant context included
- **Compression Techniques**: Structured output formatting

### Execution Optimization
- **Parallel Processing**: Concurrent task execution where possible
- **Cache Strategy**: Intelligent caching of expensive operations
- **Resource Management**: Memory and CPU optimization
- **Error Recovery**: Graceful handling of failures

## üîß Configuration & Customization

### Project Configuration
```json
{
  "super_prompt": {
    "personas": {
      "default": "architect",
      "custom_personas": "./personas/"
    },
    "sdd": {
      "quality_gates": true,
      "auto_validation": true
    },
    "amr": {
      "complexity_threshold": 0.7,
      "auto_routing": true
    }
  }
}
```

### Environment Variables
```bash
# Optional configuration
SP_SKIP_CODEX_UPGRADE=1    # Skip automatic Codex updates
SP_SELF_UPDATE=1           # Enable self-updates
SUPER_PROMPT_DEBUG=1       # Enable debug mode
```

## üöÄ Extension Points

### Custom Personas
```python
# Add custom personas
class CustomPersona(BasePersona):
    name = "data-scientist"
    specializations = ["ml", "data-analysis", "statistics"]

    def process_request(self, context: dict) -> dict:
        # Custom processing logic
        pass
```

### Custom Adapters
```python
# Integrate with new IDEs
class VSCodeAdapter(BaseAdapter):
    def generate_commands(self, personas: List[Persona]):
        # Generate VSCode-specific commands
        pass
```

### Custom SDD Stages
```python
# Add custom SDD stages
class CustomGate(QualityGate):
    def validate(self, context: dict) -> GateResult:
        # Custom validation logic
        pass
```

## üìà Monitoring & Analytics

### Execution Metrics
- **Command Usage**: Track most used commands and personas
- **Performance**: Execution time, token usage, success rates
- **Quality**: Gate pass rates, validation success
- **User Patterns**: Usage analytics and optimization opportunities

### Health Monitoring
- **System Health**: Check dependencies, versions, configurations
- **Performance Monitoring**: Track resource usage and bottlenecks
- **Error Tracking**: Log and analyze failure patterns
- **User Experience**: Monitor and improve user workflows

---

## üîó Integration Architecture

### Cursor IDE Integration
```
.cursor/
‚îú‚îÄ‚îÄ commands/super-prompt/     # Generated commands
‚îÇ   ‚îú‚îÄ‚îÄ architect.md
‚îÇ   ‚îú‚îÄ‚îÄ frontend.md
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ rules/                     # Generated rules
    ‚îú‚îÄ‚îÄ 00-organization.mdc
    ‚îú‚îÄ‚îÄ 10-sdd-core.mdc
    ‚îî‚îÄ‚îÄ ...
```

### Codex CLI Integration
```bash
# Automatic Codex updates
npm install -g @openai/codex@latest

# High reasoning mode
codex-amr high "strategic analysis"

# AMR bootstrap
codex-amr print-bootstrap > prompt.txt
```

This architecture provides a **robust, scalable, and maintainable** foundation for prompt engineering workflows across multiple development environments.