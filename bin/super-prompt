#!/usr/bin/env bash
# Super Prompt CLI Wrapper - Modernized for MCP-first architecture
set -euo pipefail

# Find the root of the super-prompt installation package.
resolve_app_home() {
  local prg="$0"
  while [ -h "$prg" ]; do
    ls_output=$(ls -ld "$prg")
    link=$(expr "$ls_output" : '.*-> \(.*\)$')
    if expr "$link" : '/.*' > /dev/null; then
      prg="$link"
    else
      prg="$(dirname "$prg")/$link"
    fi
  done
  local saved_dir="$(pwd)"
  cd "$(dirname "$prg")/.." >/dev/null
  local app_home="$(pwd -P)"
  cd "$saved_dir" >/dev/null
  printf "%s" "$app_home"
}

APP_HOME="$(resolve_app_home)"

# Auto-switch to latest npm global binary when a Homebrew/older wrapper is first on PATH
# This allows zero-config usage: if a newer binary exists at ~/.local/bin, re-exec there.
if [ -x "/Users/choi-dong-won/.local/bin/super-prompt" ] && [ "$(command -v super-prompt)" != "/Users/choi-dong-won/.local/bin/super-prompt" ]; then
  exec /Users/choi-dong-won/.local/bin/super-prompt "$@"
fi

# Find the project root (git root or current directory).
resolve_project_root() {
  if command -v git &>/dev/null; then
    local root
    root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
    if [ -n "$root" ]; then
      printf "%s" "$root"
      return 0
    fi
  fi
  printf "%s" "$(pwd)"
}

PROJECT_ROOT="$(resolve_project_root)"

resolve_python() {
  if [ -n "${PYTHON:-}" ] && command -v "$PYTHON" >/dev/null 2>&1; then
    printf "%s" "$PYTHON"
    return 0
  fi
  for candidate in python3.12 python3.11 python3.10 python3 python; do
    if command -v "$candidate" >/dev/null 2>&1; then
      printf "%s" "$candidate"
      return 0
    fi
  done
  echo "-------- ERROR: No Python interpreter found (set PYTHON env)" >&2
  return 1
}

PYTHON_BIN="$(resolve_python)" || exit 1

# With the new module-based approach, we no longer check for the existence
# of a specific source file. The python executable will handle module resolution.
# The python package is installed via the .whl file in install.js.

# Set package root for server usage
export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"
# Ensure MCP clients default to the latest published package
# Do not pin or leak an npm spec by default.
# Keeping env clean prevents accidental npx pulls of a remote version.
unset SUPER_PROMPT_NPM_SPEC || true

# Mode toggle validation and setup
resolve_mode() {
  local prev_mode="${LLM_MODE:-}"
  local mode="${LLM_MODE:-gpt}"
  local enable_gpt="${ENABLE_GPT:-}"
  local enable_grok="${ENABLE_GROK:-}"

  # Mutual exclusion validation
  if [ "$enable_gpt" = "true" ] && [ "$enable_grok" = "true" ]; then
    echo "-------- ERROR: Cannot enable both GPT and Grok modes simultaneously" >&2
    echo "-------- Please set either LLM_MODE=gpt or LLM_MODE=grok, or use --gpt or --grok flag" >&2
    exit 1
  fi

  # Environment variables take precedence, CLI flags override
  if [ "$enable_gpt" = "true" ]; then
    mode="gpt"
  elif [ "$enable_grok" = "true" ]; then
    mode="grok"
  fi

  # Validation check
  if [ "$mode" != "gpt" ] && [ "$mode" != "grok" ]; then
    echo "-------- ERROR: Invalid mode '$mode'. Supported modes: gpt, grok" >&2
    exit 1
  fi

  # Log disposal when mode changes
  if [ -n "$prev_mode" ] && [ "$prev_mode" != "$mode" ]; then
    echo "-------- mode: disposed previous provider ($prev_mode)" >&2
  fi

  echo "-------- mode: resolved to $mode" >&2
  export LLM_MODE="$mode"
}

# CLI argument parsing and command extraction
parse_args_and_cmd() {
  CMD=""
  FIRST_ARG="${1:-}"
  while [ $# -gt 0 ]; do
    case "$1" in
      --gpt)
        export ENABLE_GPT="true"
        shift
        ;;
      --grok)
        export ENABLE_GROK="true"
        shift
        ;;
      --mode=*)
        export LLM_MODE="${1#*=}"
        shift
        ;;
      --version|-v|version)
        CMD="version"
        shift
        break
        ;;
      mcp-serve|super:init|super:refresh)
        CMD="$1"
        shift
        break
        ;;
      *)
        CMD="$1"
        shift
        break
        ;;
    esac
  done
}

# Main argument parsing
parse_args_and_cmd "$@"
resolve_mode

# Map Codex-style flags to MCP tools
route_codex_flags() {
  local arg="$FIRST_ARG"
  case "$arg" in
    --architect|--sp-architect) TOOL="sp.architect" ;;
    --backend|--sp-backend) TOOL="sp.backend" ;;
    --frontend|--sp-frontend) TOOL="sp.frontend" ;;
    --security|--sp-security) TOOL="sp.security" ;;
    --performance|--sp-performance) TOOL="sp.performance" ;;
    --analyzer|--sp-analyzer) TOOL="sp.analyzer" ;;
    --qa|--sp-qa) TOOL="sp.qa" ;;
    --refactorer|--sp-refactorer) TOOL="sp.refactorer" ;;
    --devops|--sp-devops) TOOL="sp.devops" ;;
    --mentor|--sp-mentor) TOOL="sp.mentor" ;;
    --scribe|--sp-scribe) TOOL="sp.scribe" ;;
    --grok|--sp-grok) TOOL="sp.grok" ;;
    --db-expert|--sp-db-expert) TOOL="sp.db-expert" ;;
    --optimize|--sp-optimize) TOOL="sp.optimize" ;;
    --translate|--sp-translate|--tr|--sp-tr) TOOL="sp.tr" ;;
    --seq|--sp-seq) TOOL="sp.seq" ;;
    --seq-ultra|--sp-seq-ultra) TOOL="sp.seq-ultra" ;;
    --high|--sp-high) TOOL="sp.high" ;;
    --ultracompressed|--sp-ultracompressed) TOOL="sp.ultracompressed" ;;
    --dev|--sp-dev) TOOL="sp.dev" ;;
    --review|--sp-review) TOOL="sp.review" ;;
    --service-planner|--sp-service-planner) TOOL="sp.service-planner" ;;
    --docs-refector|--sp-docs-refector) TOOL="sp.docs-refector" ;;
    --doc-master|--sp-doc-master) TOOL="sp.doc-master" ;;
    # SDD
    --sp-sdd-spec|--specify|--sp-specify) TOOL="sp.specify" ;;
    --sp-sdd-plan|--plan|--sp-plan) TOOL="sp.plan" ;;
    --sp-sdd-tasks|--tasks|--sp-tasks) TOOL="sp.tasks" ;;
    --sp-sdd-implement|--implement|--sp-implement) TOOL="sp.implement" ;;
    *) TOOL="" ;;
  esac
  if [ -n "$TOOL" ]; then
    shift # consume the flag
    # Treat remaining args as a single query string
    local query="$*"
    # CLI 모드 환경변수 설정
    export SUPER_PROMPT_REQUIRE_MCP="0"  # CLI 직접 실행 허용
    export SUPER_PROMPT_ALLOW_DIRECT="true"  # 직접 CLI 실행 허용
    export SUPER_PROMPT_CLI_MODE="1"  # CLI 모드 표시

    # 사용자 프로젝트의 .super-prompt/lib/ 경로 우선 사용
    SUPER_PROMPT_USER_PATH="$PROJECT_ROOT/.super-prompt/lib"
    export PYTHONPATH="$SUPER_PROMPT_USER_PATH:${PYTHONPATH:-}"

    exec "$PYTHON_BIN" -c "
import sys
sys.path.insert(0, '$PROJECT_ROOT/.super-prompt/lib')
sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core')
from super_prompt.mcp_client import MCPClient
import asyncio

async def call_tool():
    async with MCPClient() as client:
        result = await client.call_tool('$TOOL', {'query': '$query'})
        print(result)

asyncio.run(call_tool())
"
  fi
}

route_codex_flags "$@"

resolve_direct_tool() {
  case "$1" in
    architect) echo "sp.architect" ;;
    backend) echo "sp.backend" ;;
    frontend) echo "sp.frontend" ;;
    security) echo "sp.security" ;;
    performance) echo "sp.performance" ;;
    analyzer) echo "sp.analyzer" ;;
    qa) echo "sp.qa" ;;
    refactorer) echo "sp.refactorer" ;;
    devops) echo "sp.devops" ;;
    mentor) echo "sp.mentor" ;;
    scribe) echo "sp.scribe" ;;
    grok) echo "sp.grok" ;;
    db-expert) echo "sp.db-expert" ;;
    optimize) echo "sp.optimize" ;;
    review) echo "sp.review" ;;
    dev) echo "sp.dev" ;;
    doc-master) echo "sp.doc-master" ;;
    service-planner) echo "sp.service-planner" ;;
  docs-refector) echo "sp.docs-refector" ;;
    debate) echo "sp.debate" ;;
    specify) echo "sp.specify" ;;
    plan) echo "sp.plan" ;;
    tasks) echo "sp.tasks" ;;
    implement) echo "sp.implement" ;;
    seq) echo "sp.seq" ;;
    seq-ultra) echo "sp.seq-ultra" ;;
    high) echo "sp.high" ;;
    translate|tr) echo "sp.tr" ;;
    wave) echo "sp.service-planner" ;;
    gpt-mode-on) echo "sp.gpt_mode_on" ;;
    gpt-mode-off) echo "sp.gpt_mode_off" ;;
    grok-mode-on) echo "sp.grok_mode_on" ;;
    grok-mode-off) echo "sp.grok_mode_off" ;;
    ultracompressed) echo "sp.ultracompressed" ;;
    *) echo "" ;;
  esac
}

exec_mcp_tool() {
  local tool="$1"
  shift
  export SUPER_PROMPT_REQUIRE_MCP="0"  # CLI 직접 실행 허용
  export SUPER_PROMPT_ALLOW_DIRECT="true"  # 직접 CLI 실행 허용
  export SUPER_PROMPT_CLI_MODE="1"  # CLI 모드 표시
  : "${SUPER_PROMPT_ALLOW_DIRECT:=true}"
  export SUPER_PROMPT_ALLOW_DIRECT
  export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"
  export SUPER_PROMPT_PROJECT_ROOT="${SUPER_PROMPT_PROJECT_ROOT:-$PROJECT_ROOT}"

  # 사용자 프로젝트의 .super-prompt/lib/ 경로 우선 사용
  SUPER_PROMPT_USER_PATH="$PROJECT_ROOT/.super-prompt/lib"
  export PYTHONPATH="$SUPER_PROMPT_USER_PATH:${PYTHONPATH:-}"

  # Try to find super_prompt package in system paths (fallback)
  SUPER_PROMPT_PATH=""
  for python_path in $(python3 -c "import sys; print(':'.join(sys.path))" 2>/dev/null); do
    if [ -d "$python_path/super_prompt" ]; then
      SUPER_PROMPT_PATH="$python_path"
      break
    fi
  done

  if [ -n "$SUPER_PROMPT_PATH" ]; then
    export PYTHONPATH="$SUPER_PROMPT_PATH:$PYTHONPATH"
    echo "-------- DEBUG: Found super_prompt at $SUPER_PROMPT_PATH" >&2
  else
    export PYTHONPATH="$APP_HOME/python-packages/super-prompt-core:$PYTHONPATH"
    echo "-------- DEBUG: Using package path $APP_HOME/python-packages/super-prompt-core" >&2
  fi

  # Python 패키지 루트를 환경변수로 전달
  export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"

  echo "-------- DEBUG: exec_mcp_tool called with tool=$tool" >&2
  echo "-------- DEBUG: APP_HOME = $APP_HOME" >&2
  echo "-------- DEBUG: PYTHONPATH = ${PYTHONPATH:-}" >&2
  if [ $# -gt 0 ]; then
    local query="$*"
    exec "$PYTHON_BIN" -c "
import sys
print('-------- DEBUG: sys.path before:', sys.path[:3])
sys.path.insert(0, '$PROJECT_ROOT/.super-prompt/lib')
sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core')
print('-------- DEBUG: sys.path after:', sys.path[:3])
from super_prompt.mcp_client import MCPClient
import asyncio
import json

async def call_tool():
    async with MCPClient() as client:
        result = await client.call_tool('$tool', {'query': '$query'})
        print(result)

asyncio.run(call_tool())
"
  else
    exec "$PYTHON_BIN" -c "
import sys
print('-------- DEBUG: sys.path before:', sys.path[:3])
sys.path.insert(0, '$PROJECT_ROOT/.super-prompt/lib')
sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core')
print('-------- DEBUG: sys.path after:', sys.path[:3])
from super_prompt.mcp_client import MCPClient
import asyncio

async def call_tool():
    async with MCPClient() as client:
        result = await client.call_tool('$tool', {})
        print(result)

asyncio.run(call_tool())
"
  fi
}

case "$CMD" in
  mcp-serve)
    shift
    # MCP server exposed in stdio mode for client connection
    export MCP_SERVER_MODE="1"  # Mark as MCP server mode

    # 사용자 프로젝트의 .super-prompt/lib/ 경로 우선 사용
    SUPER_PROMPT_USER_PATH="$PROJECT_ROOT/.super-prompt/lib"
    export PYTHONPATH="$SUPER_PROMPT_USER_PATH:${PYTHONPATH:-}"

    # Try to find super_prompt package in system paths (fallback)
    SUPER_PROMPT_PATH=""
    for python_path in $(python3 -c "import sys; print(':'.join(sys.path))" 2>/dev/null); do
      if [ -d "$python_path/super_prompt" ]; then
        SUPER_PROMPT_PATH="$python_path"
        break
      fi
    done

    if [ -n "$SUPER_PROMPT_PATH" ]; then
      export PYTHONPATH="$SUPER_PROMPT_PATH:$PYTHONPATH"
      echo "-------- DEBUG: Found super_prompt at $SUPER_PROMPT_PATH" >&2
    else
      export PYTHONPATH="$APP_HOME/python-packages/super-prompt-core:$PYTHONPATH"
      echo "-------- DEBUG: Using package path $APP_HOME/python-packages/super-prompt-core" >&2
    fi

    echo "-------- DEBUG: mcp-serve mode detected" >&2
    echo "-------- DEBUG: APP_HOME = $APP_HOME" >&2
    echo "-------- DEBUG: PROJECT_ROOT = $PROJECT_ROOT" >&2
    echo "-------- DEBUG: SUPER_PROMPT_USER_PATH = $SUPER_PROMPT_USER_PATH" >&2
    echo "-------- DEBUG: PYTHONPATH = ${PYTHONPATH:-}" >&2
    exec "$PYTHON_BIN" -m super_prompt.mcp_stdio "$@"
    ;;
  super:init)
    shift
    # CLI에서 직접 init 실행 (전역 ~/.cursor/mcp.json 업데이트)
    export SUPER_PROMPT_ALLOW_INIT="true"
    export SUPER_PROMPT_REQUIRE_MCP="0"  # CLI 직접 실행 허용
    export SUPER_PROMPT_ALLOW_DIRECT="true"  # 직접 CLI 실행 허용
    export SUPER_PROMPT_CLI_MODE="1"  # CLI 모드 표시
    export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"
    export SUPER_PROMPT_PROJECT_ROOT="${SUPER_PROMPT_PROJECT_ROOT:-$PROJECT_ROOT}"

    # Try to find super_prompt package in system paths
    SUPER_PROMPT_PATH=""
    for python_path in $(python3 -c "import sys; print(':'.join(sys.path))" 2>/dev/null); do
      if [ -d "$python_path/super_prompt" ]; then
        SUPER_PROMPT_PATH="$python_path"
        break
      fi
    done

    if [ -n "$SUPER_PROMPT_PATH" ]; then
      export PYTHONPATH="$SUPER_PROMPT_PATH:${PYTHONPATH:-}"
      echo "-------- DEBUG: Found super_prompt at $SUPER_PROMPT_PATH" >&2
    else
      export PYTHONPATH="$APP_HOME/python-packages/super-prompt-core:${PYTHONPATH:-}"
      echo "-------- DEBUG: Using package path $APP_HOME/python-packages/super-prompt-core" >&2
    fi

    export SUPER_PROMPT_DEBUG="1"  # 디버깅 모드 활성화
    export SUPER_PROMPT_CLI_MODE="1"  # CLI 모드 표시

    echo "-------- DEBUG: super:init command detected" >&2
    echo "-------- DEBUG: APP_HOME = $APP_HOME" >&2
    echo "-------- DEBUG: PROJECT_ROOT = $PROJECT_ROOT" >&2
    echo "-------- DEBUG: PYTHONPATH = ${PYTHONPATH:-}" >&2
    echo "-------- DEBUG: PYTHON_BIN = $PYTHON_BIN" >&2

    echo "-------- DEBUG: About to execute Python" >&2
    # Set environment variables for Python execution
    export SUPER_PROMPT_PACKAGE_ROOT="/Users/choi-dong-won/.local/lib/node_modules/@cdw0424/super-prompt"

    echo "-------- DEBUG: Command: SUPER_PROMPT_PACKAGE_ROOT='$SUPER_PROMPT_PACKAGE_ROOT' $PYTHON_BIN -c \"import sys; sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core'); from super_prompt.cli import init; import typer; typer.run(init)\" $*" >&2

    exec env SUPER_PROMPT_PACKAGE_ROOT="$SUPER_PROMPT_PACKAGE_ROOT" "$PYTHON_BIN" -c "
import sys
import os
print('=== DEBUG: Starting super:init ===', file=sys.stderr, flush=True)
print(f'DEBUG: APP_HOME = {os.environ.get(\"APP_HOME\")}', file=sys.stderr, flush=True)
print(f'DEBUG: PYTHONPATH = {os.environ.get(\"PYTHONPATH\")}', file=sys.stderr, flush=True)
print(f'DEBUG: SUPER_PROMPT_PACKAGE_ROOT = {os.environ.get(\"SUPER_PROMPT_PACKAGE_ROOT\")}', file=sys.stderr, flush=True)
print(f'DEBUG: CLI_MODE = {os.environ.get(\"SUPER_PROMPT_CLI_MODE\")}', file=sys.stderr, flush=True)
print(f'DEBUG: sys.path before = {sys.path[:3]}', file=sys.stderr, flush=True)
sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core')
print(f'DEBUG: sys.path after = {sys.path[:3]}', file=sys.stderr, flush=True)
print('DEBUG: About to import super_prompt.cli', file=sys.stderr, flush=True)
try:
    # CLI 모드에서는 MCP 서버 파일을 import하지 않음
    print('DEBUG: CLI mode - skipping mcp_server_new import', file=sys.stderr, flush=True)

    from super_prompt.cli import init
    print('DEBUG: Successfully imported init function', file=sys.stderr, flush=True)
    import typer
    print('DEBUG: About to run typer.run(init)', file=sys.stderr, flush=True)
    typer.run(init)
except Exception as e:
    print(f'DEBUG: Exception occurred: {e}', file=sys.stderr, flush=True)
    import traceback
    print(f'DEBUG: Traceback: {traceback.format_exc()}', file=sys.stderr, flush=True)
" "$@"
    ;;
  super:refresh)
    shift
    export SUPER_PROMPT_ALLOW_REFRESH="true"
    export SUPER_PROMPT_REQUIRE_MCP="0"  # CLI 직접 실행 허용
    export SUPER_PROMPT_ALLOW_DIRECT="true"  # 직접 CLI 실행 허용
    export SUPER_PROMPT_CLI_MODE="1"  # CLI 모드 표시
    export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"
    export SUPER_PROMPT_PROJECT_ROOT="${SUPER_PROMPT_PROJECT_ROOT:-$PROJECT_ROOT}"

    # 사용자 프로젝트의 .super-prompt/lib/ 경로 우선 사용
    SUPER_PROMPT_USER_PATH="$PROJECT_ROOT/.super-prompt/lib"
    export PYTHONPATH="$SUPER_PROMPT_USER_PATH:${PYTHONPATH:-}"

    # Try to find super_prompt package in system paths (fallback)
    SUPER_PROMPT_PATH=""
    for python_path in $(python3 -c "import sys; print(':'.join(sys.path))" 2>/dev/null); do
      if [ -d "$python_path/super_prompt" ]; then
        SUPER_PROMPT_PATH="$python_path"
        break
      fi
    done

    if [ -n "$SUPER_PROMPT_PATH" ]; then
      export PYTHONPATH="$SUPER_PROMPT_PATH:$PYTHONPATH"
      echo "-------- DEBUG: Found super_prompt at $SUPER_PROMPT_PATH" >&2
    else
      export PYTHONPATH="$APP_HOME/python-packages/super-prompt-core:$PYTHONPATH"
      echo "-------- DEBUG: Using package path $APP_HOME/python-packages/super-prompt-core" >&2
    fi

    echo "-------- DEBUG: super:refresh command detected" >&2
    echo "-------- DEBUG: APP_HOME = $APP_HOME" >&2
    echo "-------- DEBUG: PYTHONPATH = ${PYTHONPATH:-}" >&2
    exec "$PYTHON_BIN" -c "
import sys
sys.path.insert(0, '$PROJECT_ROOT/.super-prompt/lib')
sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core')
from super_prompt.mcp_client import MCPClient
import asyncio

async def refresh():
    async with MCPClient() as client:
        result = await client.call_tool('sp.refresh', {})
        print(result)

asyncio.run(refresh())
" "$@"
    ;;
  codex-mode-on)
    exec_mcp_tool "sp.gpt_mode_on" "$@"
    ;;
  doctor)
    # Run installation and project readiness checks
    exec node "$APP_HOME/src/doctor.js"
    ;;
  --version|-v|version)
    export SUPER_PROMPT_REQUIRE_MCP="0"  # CLI 직접 실행 허용
    export SUPER_PROMPT_ALLOW_DIRECT="true"  # 직접 CLI 실행 허용
    export SUPER_PROMPT_CLI_MODE="1"  # CLI 모드 표시

    # 사용자 프로젝트의 .super-prompt/lib/ 경로 우선 사용
    SUPER_PROMPT_USER_PATH="$PROJECT_ROOT/.super-prompt/lib"
    export PYTHONPATH="$SUPER_PROMPT_USER_PATH:${PYTHONPATH:-}"

    # Try to find super_prompt package in system paths (fallback)
    SUPER_PROMPT_PATH=""
    for python_path in $(python3 -c "import sys; print(':'.join(sys.path))" 2>/dev/null); do
      if [ -d "$python_path/super_prompt" ]; then
        SUPER_PROMPT_PATH="$python_path"
        break
      fi
    done

    if [ -n "$SUPER_PROMPT_PATH" ]; then
      export PYTHONPATH="$SUPER_PROMPT_PATH:$PYTHONPATH"
      echo "-------- DEBUG: Found super_prompt at $SUPER_PROMPT_PATH" >&2
    else
      export PYTHONPATH="$APP_HOME/python-packages/super-prompt-core:$PYTHONPATH"
      echo "-------- DEBUG: Using package path $APP_HOME/python-packages/super-prompt-core" >&2
    fi

    echo "-------- DEBUG: version command detected" >&2
    echo "-------- DEBUG: APP_HOME = $APP_HOME" >&2
    echo "-------- DEBUG: PYTHONPATH = ${PYTHONPATH:-}" >&2
    exec "$PYTHON_BIN" -c "
import sys
print('-------- DEBUG: sys.path before:', sys.path[:3])
sys.path.insert(0, '$PROJECT_ROOT/.super-prompt/lib')
sys.path.insert(0, '$APP_HOME/python-packages/super-prompt-core')
print('-------- DEBUG: sys.path after:', sys.path[:3])
from super_prompt.mcp_client import MCPClient
import asyncio

async def get_version():
    async with MCPClient() as client:
        result = await client.call_tool('sp.version', {})
        print(result)

asyncio.run(get_version())
"
    ;;
  architect|backend|frontend|security|performance|analyzer|qa|refactorer|devops|mentor|scribe|grok|db-expert|optimize|review|dev|doc-master|service-planner|debate|specify|plan|tasks|implement|seq|seq-ultra|high|translate|tr|wave|ultracompressed)
    TOOL=$(resolve_direct_tool "$CMD")
    exec_mcp_tool "$TOOL" "$@"
    ;;
  gpt-mode-on|gpt-mode-off|grok-mode-on|grok-mode-off)
    TOOL=$(resolve_direct_tool "$CMD")
    exec_mcp_tool "$TOOL" "$@"
    ;;
  *)
    echo "-------- Unknown command. Try: super:init | super:refresh | --version"
    echo "-------- Current mode: $LLM_MODE"
    exit 2
    ;;
esac
