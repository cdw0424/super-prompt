#!/usr/bin/env bash
# Super Prompt CLI Wrapper — robust, self-healing
set -euo pipefail

resolve_app_home() {
  local PRG="$0"
  while [ -h "$PRG" ]; do
    ls_output=$(ls -ld "$PRG")
    link=$(expr "$ls_output" : '.*-> \(.*\)$')
    if expr "$link" : '/.*' >/dev/null; then
      PRG="$link"
    else
      PRG="$(dirname "$PRG")/$link"
    fi
  done
  local SAVED="$(pwd)"
  cd "$(dirname "$PRG")/.." >/dev/null
  local HOME_DIR="$(pwd -P)"
  cd "$SAVED" >/dev/null
  printf "%s" "$HOME_DIR"
}

APP_HOME="$(resolve_app_home)"

# Initialization command must be handled specially to ensure the correct script is run.
# This block intercepts the init command and routes it to the full-featured Python
# script that contains the logic to install all 35+ commands.
if [ "${1-}" = "super:init" ] || [ "${1-}" = "init" ]; then
  echo "-------- Running initialization..." >&2
  
  # The REAL init script with all the logic is deeply nested within the package.
  INIT_SCRIPT_PY="$APP_HOME/.cursor/commands/super-prompt/.super-prompt/utils/cli.py"
  
  if [ -f "$INIT_SCRIPT_PY" ]; then
    echo "-------- Found main init script: $INIT_SCRIPT_PY" >&2
    # The python script's command is named "super:init". We shift off the shell
    # command ('init' or 'super:init') and pass the rest of the args to the script.
    shift
    exec python3 "$INIT_SCRIPT_PY" "super:init" "$@"
  else
    echo "❌ FATAL: Main initialization script not found." >&2
    echo "   Looked for: $INIT_SCRIPT_PY" >&2
    echo "   This might indicate a broken installation." >&2
    exit 1
  fi
fi

# Route 'codex-amr' subcommand to Node CLI without affecting legacy behavior
if [ "${1-}" = "codex-amr" ]; then
  shift
  if command -v node >/dev/null 2>&1; then
    exec node "$(dirname "$0")/codex-amr.js" "$@"
  else
    echo "-------- Node.js is required for codex-amr commands" >&2
    exit 1
  fi
fi

# The old `super:init` mapping is now superseded by the logic block above.
# if [ "${1-}" = "super:init" ]; then
#  shift
#  set -- init "$@"
# fi

resolve_project_root() {
  if command -v git >/dev/null 2>&1; then
    if GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null); then
      printf "%s" "$GIT_ROOT"
      return 0
    fi
  fi
  printf "%s" "$(pwd)"
}

PROJECT_ROOT="$(resolve_project_root)"

# Detect persona flags: --sp-<persona>
detect_sp_persona() {
  local slug=""; local i
  for i in "$@"; do
    case "$i" in
      --sp-*) slug="${i#--sp-}"; break ;;
    esac
  done
  [ -n "$slug" ] && printf "%s" "$slug" || return 1
}

# If persona flag present, route directly to enhanced persona processor
if persona_slug="$(detect_sp_persona "$@" 2>/dev/null)"; then
  # Filter user input: tokens not starting with '--', '-', or '/'
  USER_INPUT=""
  for tok in "$@"; do
    case "$tok" in
      --sp-*) ;; # drop persona flag
      --*) ;;    # drop other flags
      -*) ;;     # drop short flags
      /*) ;;     # drop slash tags
      *) USER_INPUT+="$tok ";;
    esac
  done
  USER_INPUT="${USER_INPUT%% }"

  # Resolve processor path (prefer project, fallback to package)
  PROCESSOR_PATH="$PROJECT_ROOT/.super-prompt/utils/cursor-processors/enhanced_persona_processor.py"
  if [ ! -f "$PROCESSOR_PATH" ]; then
    PROCESSOR_PATH="$APP_HOME/.super-prompt/utils/cursor-processors/enhanced_persona_processor.py"
  fi
  if [ ! -f "$PROCESSOR_PATH" ]; then
    echo "-------- ERROR: Enhanced persona processor not found" >&2
    exit 1
  fi

  exec python3 "$PROCESSOR_PATH" --persona "$persona_slug" $USER_INPUT
fi

# Determine which Python CLI to run and find venv Python (project-local preferred)
resolve_cli_script() {
  local project_cli="$PROJECT_ROOT/.super-prompt/cli.py"
  local packaged_cli="$APP_HOME/.super-prompt/cli.py"

  if [ -f "$project_cli" ]; then
    echo "-------- Using project Python core: $project_cli" >&2
    printf "%s" "$project_cli"
    return 0
  fi

  if [ -f "$packaged_cli" ]; then
    echo "-------- Using packaged Python core: $packaged_cli" >&2
    printf "%s" "$packaged_cli"
    return 0
  fi

  printf "%s" ""
  return 1
}

# Find the best Python interpreter (prefer venv)
resolve_python_interpreter() {
  local cli_script="$1"
  local cli_dir="$(dirname "$cli_script")"
  local super_prompt_dir="$(dirname "$cli_dir")"

  # Try venv Python first
  local venv_dir="$super_prompt_dir/venv"
  if [ -d "$venv_dir" ]; then
    # Detect platform more reliably
    local platform="$(uname -s 2>/dev/null || echo "Unknown")"
    case "$platform" in
      Darwin|Linux|*BSD*)
        local venv_python="$venv_dir/bin/python"
        ;;
      MINGW*|MSYS*|CYGWIN*|Windows_NT*)
        local venv_python="$venv_dir/Scripts/python.exe"
        ;;
      *)
        # Default fallback - try both locations
        if [ -f "$venv_dir/bin/python" ]; then
          local venv_python="$venv_dir/bin/python"
        elif [ -f "$venv_dir/Scripts/python.exe" ]; then
          local venv_python="$venv_dir/Scripts/python.exe"
        else
          local venv_python=""
        fi
        ;;
    esac

    if [ -f "$venv_python" ]; then
      echo "-------- Using venv Python: $venv_python" >&2
      printf "%s" "$venv_python"
      return 0
    fi
  fi

  # Fallback to system Python
  if command -v python3 >/dev/null 2>&1; then
    printf "%s" "python3"
    return 0
  elif command -v python >/dev/null 2>&1; then
    printf "%s" "python"
    return 0
  fi

  return 1
}

CLI_SCRIPT="$(resolve_cli_script || true)"

# Opportunistic project bootstrap: ensure .super-prompt exists on init
maybe_bootstrap_super_prompt() {
  # Non-destructive bootstrap: if missing locally, copy bundled assets
  if [ ! -d ".super-prompt" ] && [ -d "${APP_HOME}/.super-prompt" ]; then
    echo "-------- Installing project .super-prompt utilities"
    cp -R "${APP_HOME}/.super-prompt" ".super-prompt" 2>/dev/null || true

    # Also copy packages/core-py for Python module imports
    if [ -d "${APP_HOME}/packages" ]; then
      cp -R "${APP_HOME}/packages" ".super-prompt/" 2>/dev/null || true
    fi

    # Copy .cursor directory for Cursor IDE integration (including grok commands)
    if [ -d "${APP_HOME}/.cursor" ]; then
      echo "-------- Installing Cursor IDE integration (grok, personas, etc.)"
      cp -R "${APP_HOME}/.cursor" ".cursor" 2>/dev/null || true
    fi

    # Best-effort: ensure python files are executable
    if command -v find >/dev/null 2>&1; then
      find .super-prompt -type f -name "*.py" -exec chmod 755 {} + 2>/dev/null || true
    fi
  fi
}

ensure_codex_latest() {
  if [ "${SP_SKIP_CODEX_UPGRADE:-0}" = "1" ]; then return 0; fi
  if command -v npm >/dev/null 2>&1; then
    echo "-------- Upgrading Codex CLI to latest (@openai/codex)"
    npm install -g @openai/codex@latest >/dev/null 2>&1 || true
  fi
}

ensure_self_latest() {
  # Opt-in self-update to avoid accidental downgrade
  if [ "${SP_SELF_UPDATE:-0}" != "1" ]; then
    # honor legacy skip flag too
    return 0
  fi
  if command -v npm >/dev/null 2>&1; then
    echo "-------- Checking Super Prompt updates (@cdw0424/super-prompt)"
    sudo npm install -g @cdw0424/super-prompt@latest >/dev/null 2>&1 || true
  fi
}

ensure_cli() {
  if [ -n "${CLI_SCRIPT:-}" ] && [ -f "$CLI_SCRIPT" ]; then return 0; fi
  if [ -f "${APP_HOME}/install.js" ] && command -v node >/dev/null 2>&1; then
    echo "-------- Finalizing installation (running postinstall)"
    (cd "$APP_HOME" && node install.js) || true
  fi
  # Re-resolve after potential install
  CLI_SCRIPT="$(resolve_cli_script || true)"
  [ -n "${CLI_SCRIPT:-}" ] && [ -f "$CLI_SCRIPT" ]
}

ensure_self_latest
ensure_codex_latest

# Pre-flight: ensure required Python libs are available for CLI import
python3 - <<'PY' >/dev/null 2>&1 || true
import sys, subprocess
try:
    import typer, yaml, pathspec  # type: ignore
except Exception:
    try:
        subprocess.run([sys.executable, '-m', 'pip', 'install', 'typer>=0.9.0', 'pyyaml>=6.0', 'pathspec>=0.11.0'], check=False)
    except Exception:
        pass
PY

if ! ensure_cli; then
  echo "❌ Python CLI not found. Expected at one of:"
  echo "   - $PROJECT_ROOT/.super-prompt/cli.py"
  echo "   - $APP_HOME/.super-prompt/cli.py"
  echo "-------- Remediation:"
  echo "   - npm config set ignore-scripts false"
  echo "   - sudo npm rebuild -g @cdw0424/super-prompt"
  echo "   - or run: node '${APP_HOME}/install.js'"
  echo "   - or ensure your repo includes '.super-prompt/cli.py'"
  exit 1
fi

# Perform bootstrap if needed (non-destructive), for any command
maybe_bootstrap_super_prompt

# Check Python version
python3 - <<'PY' || { echo "❌ Python 3.7+ required"; exit 1; }
import sys
req=(3,7)
sys.exit(0 if sys.version_info>=req else 1)
PY

# Activate venv and use venv Python if available
if [ -n "$CLI_SCRIPT" ]; then
  VENV_PYTHON="$(resolve_python_interpreter "$CLI_SCRIPT" 2>/dev/null || true)"

  if [ -n "$VENV_PYTHON" ] && [ "$VENV_PYTHON" != "python3" ] && [ "$VENV_PYTHON" != "python" ]; then
    # Found venv Python - activate environment
    VENV_DIR="$(dirname "$(dirname "$VENV_PYTHON")")"
    if [ -f "$VENV_DIR/pyvenv.cfg" ]; then
      echo "-------- Activating Python virtual environment: $VENV_DIR" >&2
      # Set up venv environment variables
      export VIRTUAL_ENV="$VENV_DIR"
      export PATH="$(dirname "$VENV_PYTHON"):$PATH"
      unset PYTHONHOME
    fi
    exec "$VENV_PYTHON" "$CLI_SCRIPT" "$@"
  else
    # Fallback to system Python
    exec python3 "$CLI_SCRIPT" "$@"
  fi
else
  echo "❌ Python CLI not found" >&2
  exit 1
fi
