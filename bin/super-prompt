#!/usr/bin/env bash
# Super Prompt CLI Wrapper - Modernized for MCP-first architecture
set -euo pipefail

# Find the root of the super-prompt installation package.
resolve_app_home() {
  local prg="$0"
  while [ -h "$prg" ]; do
    ls_output=$(ls -ld "$prg")
    link=$(expr "$ls_output" : '.*-> \(.*\)$')
    if expr "$link" : '/.*' > /dev/null; then
      prg="$link"
    else
      prg="$(dirname "$prg")/$link"
    fi
  done
  local saved_dir="$(pwd)"
  cd "$(dirname "$prg")/.." >/dev/null
  local app_home="$(pwd -P)"
  cd "$saved_dir" >/dev/null
  printf "%s" "$app_home"
}

APP_HOME="$(resolve_app_home)"

# Find the project root (git root or current directory).
resolve_project_root() {
  if command -v git &>/dev/null; then
    local root
    root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
    if [ -n "$root" ]; then
      printf "%s" "$root"
      return 0
    fi
  fi
  printf "%s" "$(pwd)"
}

PROJECT_ROOT="$(resolve_project_root)"

# Prefer project venv; fall back to package venv
VENV_DIR_PROJECT="$PROJECT_ROOT/.super-prompt/venv"
VENV_DIR_PACKAGE="$APP_HOME/.super-prompt/venv"

# Resolve the correct Python executable from the venv.
resolve_venv_python() {
    local platform
    platform="$(uname -s 2>/dev/null || echo "Unknown")"

    # Try project venv first, then package venv
    local candidates=()
    case "$platform" in
      Darwin|Linux|*BSD*)
        candidates+=("$VENV_DIR_PROJECT/bin/python")
        candidates+=("$VENV_DIR_PACKAGE/bin/python")
        ;;
      MINGW*|MSYS*|CYGWIN*|Windows_NT*)
        candidates+=("$VENV_DIR_PROJECT/Scripts/python.exe")
        candidates+=("$VENV_DIR_PACKAGE/Scripts/python.exe")
        ;;
      *)
        candidates+=("$VENV_DIR_PROJECT/bin/python")
        candidates+=("$VENV_DIR_PROJECT/Scripts/python.exe")
        candidates+=("$VENV_DIR_PACKAGE/bin/python")
        candidates+=("$VENV_DIR_PACKAGE/Scripts/python.exe")
        ;;
    esac

    for py in "${candidates[@]}"; do
      if [ -f "$py" ]; then
        printf "%s" "$py"
        return 0
      fi
    done

    return 1
}

# Find the venv Python interpreter.
VENV_PYTHON=$(resolve_venv_python || true)

# If the venv Python is not found, fall back to the system python3.
if [ -z "${VENV_PYTHON:-}" ]; then
    echo "-------- WARNING: venv not found. Falling back to system python3." >&2
    VENV_PYTHON="python3"
fi

# With the new module-based approach, we no longer check for the existence
# of a specific source file. The python executable will handle module resolution.
# The python package is installed via the .whl file in install.js.

# 패키지 루트 고정 (서버가 활용)
export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"
# 현재 패키지 버전 -> mcp.json 등록에 사용
PKG_VERSION="$(node -p "require('$APP_HOME/package.json').version" 2>/dev/null || echo "")"
if [ -n "$PKG_VERSION" ]; then
  export SUPER_PROMPT_NPM_SPEC="@cdw0424/super-prompt@$PKG_VERSION"
else
  export SUPER_PROMPT_NPM_SPEC="@cdw0424/super-prompt@latest"
fi

# 모드 토글 검증 및 설정
resolve_mode() {
  local prev_mode="${LLM_MODE:-}"
  local mode="${LLM_MODE:-gpt}"
  local enable_gpt="${ENABLE_GPT:-}"
  local enable_grok="${ENABLE_GROK:-}"

  # 상호배타 검증
  if [ "$enable_gpt" = "true" ] && [ "$enable_grok" = "true" ]; then
    echo "-------- ERROR: Cannot enable both GPT and Grok modes simultaneously" >&2
    echo "-------- Please set either LLM_MODE=gpt or LLM_MODE=grok, or use --gpt or --grok flag" >&2
    exit 1
  fi

  # 환경변수 우선, CLI 플래그로 오버라이드
  if [ "$enable_gpt" = "true" ]; then
    mode="gpt"
  elif [ "$enable_grok" = "true" ]; then
    mode="grok"
  fi

  # 유효성 검증
  if [ "$mode" != "gpt" ] && [ "$mode" != "grok" ]; then
    echo "-------- ERROR: Invalid mode '$mode'. Supported modes: gpt, grok" >&2
    exit 1
  fi

  # 모드 변경 시 dispose 로깅
  if [ -n "$prev_mode" ] && [ "$prev_mode" != "$mode" ]; then
    echo "-------- mode: disposed previous provider ($prev_mode)" >&2
  fi

  echo "-------- mode: resolved to $mode" >&2
  export LLM_MODE="$mode"
}

# CLI 인자 파싱 및 명령 추출
parse_args_and_cmd() {
  CMD=""
  FIRST_ARG="${1:-}"
  while [ $# -gt 0 ]; do
    case "$1" in
      --gpt)
        export ENABLE_GPT="true"
        shift
        ;;
      --grok)
        export ENABLE_GROK="true"
        shift
        ;;
      --mode=*)
        export LLM_MODE="${1#*=}"
        shift
        ;;
      --version|-v|version)
        CMD="version"
        shift
        break
        ;;
      mcp-server|super:init|super:refresh)
        CMD="$1"
        shift
        break
        ;;
      *)
        CMD="$1"
        shift
        break
        ;;
    esac
  done
}

# 메인 인자 파싱
parse_args_and_cmd "$@"
resolve_mode

# Map Codex-style flags to MCP tools
route_codex_flags() {
  local arg="$FIRST_ARG"
  case "$arg" in
    --architect|--sp-architect) TOOL="sp.architect" ;;
    --backend|--sp-backend) TOOL="sp.backend" ;;
    --frontend|--sp-frontend) TOOL="sp.frontend" ;;
    --security|--sp-security) TOOL="sp.security" ;;
    --performance|--sp-performance) TOOL="sp.performance" ;;
    --analyzer|--sp-analyzer) TOOL="sp.analyzer" ;;
    --qa|--sp-qa) TOOL="sp.qa" ;;
    --refactorer|--sp-refactorer) TOOL="sp.refactorer" ;;
    --devops|--sp-devops) TOOL="sp.devops" ;;
    --mentor|--sp-mentor) TOOL="sp.mentor" ;;
    --scribe|--sp-scribe) TOOL="sp.scribe" ;;
    --grok|--sp-grok) TOOL="sp.grok" ;;
    --db-expert|--sp-db-expert) TOOL="sp.db-expert" ;;
    --optimize|--sp-optimize) TOOL="sp.optimize" ;;
    --translate|--sp-translate|--tr|--sp-tr) TOOL="sp.tr" ;;
    --seq|--sp-seq) TOOL="sp.seq" ;;
    --seq-ultra|--sp-seq-ultra) TOOL="sp.seq-ultra" ;;
    --ultracompressed|--sp-ultracompressed) TOOL="sp.ultracompressed" ;;
    --dev|--sp-dev) TOOL="sp.dev" ;;
    --review|--sp-review) TOOL="sp.review" ;;
    --service-planner|--sp-service-planner) TOOL="sp.service-planner" ;;
    # SDD
    --sp-sdd-spec|--specify|--sp-specify) TOOL="sp.specify" ;;
    --sp-sdd-plan|--plan|--sp-plan) TOOL="sp.plan" ;;
    --sp-sdd-tasks|--tasks|--sp-tasks) TOOL="sp.tasks" ;;
    --sp-sdd-implement|--implement|--sp-implement) TOOL="sp.implement" ;;
    *) TOOL="" ;;
  esac
  if [ -n "$TOOL" ]; then
    shift # consume the flag
    # Treat remaining args as a single query string
    local query="$*"
    exec node "$APP_HOME/src/mcp-client.js" call "$TOOL" "--query=$query"
  fi
}

route_codex_flags "$@"

case "$CMD" in
  mcp-server)
    # 서버만 직접 노출 (클라이언트가 붙음)
    export MCP_SERVER_MODE="1"  # Mark as MCP server mode
    exec "$VENV_PYTHON" -m super_prompt.mcp_server "$@"
    ;;
  super:init)
    # If running inside the package repo root, avoid self-copy bug by using Node fallback
    if [ "$APP_HOME" = "$PROJECT_ROOT" ]; then
      exec node "$APP_HOME/src/mcp-client.js" call sp.init "$@"
    else
      # Initialize via Python CLI, targeting the actual project root
      export SUPER_PROMPT_REQUIRE_MCP="0"
      export SUPER_PROMPT_ALLOW_INIT="true"
      export SUPER_PROMPT_PACKAGE_ROOT="$APP_HOME"
      export SUPER_PROMPT_PROJECT_ROOT="$PROJECT_ROOT"
      export PYTHONPATH="$APP_HOME/packages/core-py:${PYTHONPATH:-}"
      cd "$PROJECT_ROOT"
      exec "$VENV_PYTHON" -m super_prompt.cli "$@"
    fi
    ;;
  super:refresh)
    exec node "$APP_HOME/src/mcp-client.js" call sp.refresh "$@"
    ;;
  grok-mode-on)
    exec node "$APP_HOME/src/mode/set.js" grok
    ;;
  gpt-mode-on|codex-mode-on)
    exec node "$APP_HOME/src/mode/set.js" gpt
    ;;
  --version|-v|version)
    exec node "$APP_HOME/src/mcp-client.js" call sp.version
    ;;
  *)
    echo "-------- Unknown command. Try: super:init | super:refresh | --version"
    echo "-------- Current mode: $LLM_MODE"
    exit 2
    ;;
esac
